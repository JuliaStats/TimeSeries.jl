var documenterSearchIndex = {"docs":
[{"location":"combine/#Combine-methods","page":"Combine methods","title":"Combine methods","text":"TimeSeries supports merging two TimeArrays, and squishing the timestamp to a longer-term interval while representing values that make sense.","category":"section"},{"location":"combine/#merge","page":"Combine methods","title":"merge","text":"The merge method performs joins between two TimeArrays. The default behaviour is to perform an inner join, such that the resulting TimeArray contains only timestamps that both TimeArrays share, and values that correspond to that timestamp.\n\nThe AAPL object from MarketData has 8,336 rows of data from Dec 12, 1980 to Dec 31, 2013. If we merge it with the CAT object, which contains 13,090 rows of data from Jan 2, 1962 to Dec 31, 2013 we might expect the resulting TimeArray to have 8,336 rows of data, corresponding to the length of AAPL. This assumes that every day that Apple Computer, Inc. traded, Caterpillar, Inc likewise traded. It turns out that this isn't true. CAT did not trade on Sep 27, 1985 because Hurricane Glorio shut down the New York Stock Exchange. Apple Computer trades on the electronic NASDAQ and its trading was not halted on that day. The result of the merge should then be 8,335 rows:\n\nusing TimeSeries\nusing MarketData\nAppleCat = merge(AAPL, CAT);\nlength(AppleCat)\n\nLeft, right, and outer joins can also be performed by passing the corresponding symbol. These joins introduce NaN values when data for a particular timestamp only exists in one of the series to be merged. For example:\n\nmerge(op[1:3], cl[2:4]; method=:left)\nmerge(op[1:3], cl[2:4]; method=:right)\nmerge(op[1:3], cl[2:4]; method=:outer)\n\nThe merge method allows users to specify the value for the meta field of the merged object. When that value is not explicitly provided, merge will concatenate the meta field values, assuming these values to be strings. This covers the vast majority of use cases. In edge cases when users do not provide a meta value and both field values are not strings, the merged object will take on Void as its meta field value:\n\nmeta(AppleCat)\nCatApple = merge(CAT, AAPL; meta=47);\nmeta(CatApple)\nmeta(merge(AppleCat, CatApple))","category":"section"},{"location":"combine/#collapse","page":"Combine methods","title":"collapse","text":"The collapse method allows for compressing data into a larger time frame. For example, converting daily data into monthly data. When compressing dates, something rational has to be done with the values that lived in the more granular time frame. To define what happens, a function call is made. In our example, we want to compress the daily cl closing prices from daily to monthly. It makes sense for us to take the last value known and have that represented with the corresponding timestamp. A non-exhaustive list of valid time methods is presented below.\n\nDates method Time length\nDates.quarter quarterly\nday daily\nweek weekly, starting from Monday.\nmonth monthly\nyear yearly\nhour hourly\nminute minutely\nsecond secondly\n\nShowing this code in REPL:\n\nusing TimeSeries\nusing MarketData\ncollapse(cl, month, last)\n\nWe can also supply the function that chooses the timestamp and the function that determines the corresponding value independently:\n\nusing Statistics\ncollapse(cl, month, last, mean)","category":"section"},{"location":"combine/#vcat","page":"Combine methods","title":"vcat","text":"The vcat method is used to concatenate time series: if you have two time series with the same columns, this function can merge them into a single object. Notably, it can be used to merge data that is split into multiple files. Its behaviour is quite different from merge, which does not consider that its arguments are actually the same time series.\n\nThis concatenation is vertical (vcat) because it does not create columns, it extends existing ones (which are represented vertically).","category":"section"},{"location":"combine/#map","page":"Combine methods","title":"map","text":"This function allows complete transformation of the data within the time series, with alteration on both the time stamps and the associated values. It works exactly like Base.map: the first argument is a binary function (the time stamp and the values) that returns two values, respectively the new time stamp and the new vector of values. It does not perform any kind of compression like collapse, but rather transformations.\n\nThe simplest example is to postpone all time stamps in the given time series, here by one year:\n\nusing TimeSeries\nusing Dates\nta = TimeArray([Date(2015, 10, 01), Date(2015, 11, 01)], [15, 16])\nmap((timestamp, values) -> (timestamp + Year(1), values), ta)","category":"section"},{"location":"combine/#Base.merge","page":"Combine methods","title":"Base.merge","text":"merge(ta1::TimeArray{T}, ta2::TimeArray{T}, [tas::TimeArray{T}...];\n      method = :inner, colnames = [...], padvalue = NaN)\n\nMerge several TimeArrays along with the time index.\n\nArgument\n\nmethod::Symbol: :inner, :outer, :left or :right.\n\n\n\n\n\n","category":"function"},{"location":"combine/#TimeSeries.collapse","page":"Combine methods","title":"TimeSeries.collapse","text":"collapse(ta, period, timestamp; ...)\ncollapse(ta, period, timestamp, value; kw...)\n\n\nThe collapse method allows for compressing data into a larger time frame. \n\nFor example, converting daily data into monthly data. When compressing dates, something rational has to be done with the values that lived in the more granular time frame. To define what happens, a function call is made.\n\nArguments:\n\nta::TimeArray: Original data\nperiod::Union{Function,Dates.Period}: Period or method for determining the period\ntimestamp::Function: Method that determines which timestamp represents the whole period, e.g. last\nvalue::Function = timestamp: Method that should be applied to the data within the period, e.g. mean\n\ncollapse(ta, month, last)\ncollapse(ta, month, last, mean)\n\n\n\n\n\n","category":"function"},{"location":"combine/#Base.vcat-Tuple{Vararg{TimeArray}}","page":"Combine methods","title":"Base.vcat","text":"vcat(tas)\n\n\nConcatenate two TimeArray into single object.\n\nIf there are duplicated timestamps, we will keep order as the function input.\n\njulia> a = TimeArray([Date(2015, 10, 1), Date(2015, 10, 2), Date(2015, 10, 3)], [1, 2, 3]);\n\njulia> b = TimeArray([Date(2015, 10, 2), Date(2015, 10, 3)], [4, 5]);\n\njulia> [a; b]\n5×1 TimeArray{Int64,1,Date,Array{Int64,1}} 2015-10-01 to 2015-10-03\n│            │ A     │\n├────────────┼───────┤\n│ 2015-10-01 │ 1     │\n│ 2015-10-02 │ 2     │\n│ 2015-10-02 │ 4     │\n│ 2015-10-03 │ 3     │\n│ 2015-10-03 │ 5     │\n\n\n\n\n\n","category":"method"},{"location":"retime/#Retime","page":"Retime","title":"Retime","text":"The retime function allows you to retime, i.e. change the timestamps of a TimeArray, similar to what Matlab's retime does.\n\nusing Plots, Dates, TimeSeries\ndefault(show = false)  # hide\nENV[\"GKSwstype\"] = \"100\" # hide\ngr()\ntimestamps = range(DateTime(2020, 1, 1), length = 7*24, step = Hour(1))\nta = TimeArray(timestamps, cumsum(randn(7*24)), [:a])","category":"section"},{"location":"retime/#Using-a-new-time-step","page":"Retime","title":"Using a new time step","text":"retime(ta, Minute(15))","category":"section"},{"location":"retime/#Using-new-timestep-vector","page":"Retime","title":"Using new timestep vector","text":"new_timestamps = range(DateTime(2020, 1, 1), DateTime(2020, 1, 2), step = Minute(15))\nretime(ta, new_timestamps)","category":"section"},{"location":"retime/#Irregular-timestamps","page":"Retime","title":"Irregular timestamps","text":"You can perform retime on irregularly spaced timestamps, both using a TimeArray with irregular timestamps or using a vector of irregular timestamps. Depending on the timestamps upsampling or downsampling is used. \n\nnew_timestamps = vcat(\n    range(DateTime(2020, 1, 1), DateTime(2020, 1, 2)-Minute(15), step = Minute(15)), \n    range(DateTime(2020, 1, 2), DateTime(2020, 1, 3), step = Hour(1)),\n)\nretime(ta, new_timestamps)","category":"section"},{"location":"retime/#Upsampling","page":"Retime","title":"Upsampling","text":"Interpolation is done using the upsample argument. If no data is directly hit, the specified upsample method is used. Available upsample methods are:\n\nLinear() or :linear\nNearest() or :nearest\nPrevious() or :previous\nNext() or :next\n\nta_ = retime(ta, Minute(15), upsample=Linear())\n\nplot(ta)\nplot!(ta_)\nsavefig(\"retime-upsampling.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"retime/#Downsampling","page":"Retime","title":"Downsampling","text":"Downsampling or aggregation is done using the downsample argument. This applies a function to each interval not including the right-edge of the interval. If no data is present in the interval the specified upsample method is used. Available downsample methods are:\n\nMean() or :mean\nMin() or :min\nMax() or :max\nCount() or :count\nSum() or :sum\nMedian() or :median\nFirst() or :first\nLast() or :last\n\nta_ = retime(ta, Hour(6), downsample=Mean())\n\nplot(ta)\nplot!(ta_)\nsavefig(\"retime-downsample.svg\"); nothing # hide\n\n(Image: )","category":"section"},{"location":"retime/#Extrapolation","page":"Retime","title":"Extrapolation","text":"Extrapolation at the beginning and end of the time series is done using the extrapolate argument.  Available extrapolate methods are:\n\nFillConstant(value) or :fillconstant\nNearestExtrapolate() or :nearest\nMissingExtrapolate() or :missing\nNaNExtrapolate() or :nan\n\nnew_timestamps = range(DateTime(2019, 12, 31), DateTime(2020, 1, 2), step = Minute(15))\nta_ = retime(ta, new_timestamps, extrapolate=MissingExtrapolate())","category":"section"},{"location":"apply/#Apply-methods","page":"Apply methods","title":"Apply methods","text":"Common transformation of time series data involves lagging, leading, calculating change, windowing operations and aggregation operations. Each of these methods include keyword arguments that include defaults.","category":"section"},{"location":"apply/#lag","page":"Apply methods","title":"lag","text":"The lag method simply described is putting yesterday's value in today's timestamp. This is the most common use case, though there are many times the distance between timestamps is not 1 time unit. An arbitrary integer distance for lagging is supported, with the default equal to 1.\n\nThe value of the cl object on Jan 3, 2000 is 111.94. On Jan 4, 2000 it is 102.50 and on Jan 5, 2000 it's 104.0:\n\nusing MarketData\ncl[1:3]\n\nThe lag method moves values up one day:\n\nlag(cl[1:3])\n\nYou will notice that since there is no known value for lagging the first day, the observation on that timestamp is omitted. This behavior is common in time series. When observations are consumed in a transformation, the artifact dates are not preserved with a missingness value. To pad the returned TimeArray with NaN values instead, you can pass padding=true as a keyword argument:\n\nlag(cl[1:3]; padding=true)","category":"section"},{"location":"apply/#lead","page":"Apply methods","title":"lead","text":"Leading values operates similarly to lagging values, but moves things in the other direction. Arbitrary time distances is also supported:\n\nusing TimeSeries\nusing MarketData\nlead(cl[1:3])\n\nSince we are leading an object of length 3, only two values will be transformed because we have lost a day to the transformation.\n\nThe cl object is 500 rows long so if we lead by 499 days, we should put the last observation in the object (which happens to be on Dec 31, 2001) into the first date's value slot:\n\nlead(cl, 499)","category":"section"},{"location":"apply/#diff","page":"Apply methods","title":"diff","text":"Differentiating a time series calculates the finite difference between two consecutive points in the time series. The resulting time series will have less points than the original. Those points are filled with NaN values if padding=true.\n\nusing TimeSeries\nusing MarketData\ndiff(cl)\n\nYou can calculate higher order differences by using the keyword parameter differences, accepting a positive integer. The default value is differences=1. For instance, passing differences=2 is equivalent to doing diff(diff(cl)).","category":"section"},{"location":"apply/#percentchange","page":"Apply methods","title":"percentchange","text":"Calculating change between timestamps is a very common time series operation. We use the terms percent change, returns and rate of change interchangably. Depending on which domain you're using time series, you may prefer one name over the other.\n\nThis package names the function that performs this transformation percentchange. You're welcome to change this of course if that represents too many letters for you to type:\n\nusing TimeSeries\nroc = percentchange\n\nThe percentchange method includes the option to return a simple return or a log return. The default is set to simple:\n\nusing MarketData\npercentchange(cl)\n\nLog returns are popular for downstream calculations since adding returns is simpler than multiplying them. To create log returns, pass the symbol :log to the method:\n\npercentchange(cl, :log)","category":"section"},{"location":"apply/#moving","page":"Apply methods","title":"moving","text":"Often when working with time series, you want to take a sliding window view of the data and perform a calculation on it. The simplest example of this is the moving average. For a 10-period moving average, you take the first ten values, sum then and divide by 10 to get their average. Then you slide the window down one and to the same thing. This operation involves two important arguments: the function that you want to use on your window and the size of the window you want to apply that function over.\n\nIn our moving average example, we would pass arguments this way:\n\nusing TimeSeries\nusing MarketData\nusing Statistics\nmoving(mean, cl, 10)\n\nAs mentioned previously, we lose the first nine observations to the consuming nature of this operation. They are not missing per se, they simply do not exist.","category":"section"},{"location":"apply/#upto","page":"Apply methods","title":"upto","text":"Another operation common in time series analysis is an aggregation function. TimeSeries supports this with the upto method. Suppose you want to keep track of the sum of all the values from the beginning to the present timestamp. You would use the upto method like this:\n\nusing TimeSeries\nusing MarketData\nupto(sum, cl)","category":"section"},{"location":"apply/#basecall","page":"Apply methods","title":"basecall","text":"Because the algorithm for the upto method needs to be optimized further, it might be better to use a base method in its place when one is available. Taking our summation example above, we could instead use the basecall method and realize substantial performance improvements:\n\nusing TimeSeries\nusing MarketData\nbasecall(cl, cumsum)","category":"section"},{"location":"apply/#TimeSeries.moving","page":"Apply methods","title":"TimeSeries.moving","text":"moving(f, ta::TimeArray{T,1}, w::Integer; padding = false)\n\nApply user-defined function f to a 1D TimeArray with window size w.\n\nExample\n\nTo calculate the simple moving average of a time series:\n\nmoving(mean, ta, 10)\n\n\n\n\n\nmoving(f, ta::TimeArray{T,2}, w::Integer; padding = false, dims = 1, colnames = [...])\n\nExample\n\nIn case of dims = 2, the user-defined function f will get a 2D Array as input.\n\nmoving(ohlc, 10; dims=2, colnames=[:A, ...]) do\n    # given that `ohlc` is a 500x4 `TimeArray`,\n    # size(A) is (10, 4)\n    ...\nend\n\n\n\n\n\n","category":"function"},{"location":"modify/#Modify-existing-TimeArrays","page":"Modify existing TimeArrays","title":"Modify existing TimeArrays","text":"","category":"section"},{"location":"modify/#rename-and-rename!","page":"Modify existing TimeArrays","title":"rename and rename!","text":"The rename method allows the column name(s) to be changed. The rename! is used for in-place update.\n\nfirst(rename(cl, :Close′))\nfirst(rename(cl, [:Close′]))\nfirst(rename(ohlc, [:Open′, :High′, :Low′, :Close′]))\nfirst(rename(ohlc, :Open => :Open′))\nfirst(rename(ohlc, :Open => :Open′, :Close => :Close′))\nfirst(rename(ohlc, Dict(:Open => :Open′, :Close => :Close′)...))\nfirst(rename(Symbol ∘ uppercase ∘ string, ohlc))\nfirst(rename(uppercase, ohlc, String))","category":"section"},{"location":"modify/#TimeSeries.rename","page":"Modify existing TimeArrays","title":"TimeSeries.rename","text":"rename(ta::TimeArray, colnames::Vector{Symbol})\nrename(ta::TimeArray, colname::Symbol)\nrename(ta::TimeArray, orig => new, ...)\nrename(f::Base.Callable, ta, colnametyp)\n\nRename the columns of a TimeArray.\n\nSee also rename!.\n\nArguments\n\ncolnametyp is the input type for the function f. The valid value is Symbol or String.\n\n\n\n\n\n","category":"function"},{"location":"modify/#TimeSeries.rename!","page":"Modify existing TimeArrays","title":"TimeSeries.rename!","text":"rename!(ta::TimeArray, colnames::Vector{Symbol})\nrename!(ta::TimeArray, colname::Symbol)\nrename!(ta::TimeArray, orig => new, ...)\nrename!(f::Base.Callable, ta, colnametyp)\n\nIn-place rename the columns of a TimeArray.\n\nSee also rename.\n\nArguments\n\ncolnametyp is the input type for the function f. The valid value is Symbol or String.\n\n\n\n\n\n","category":"function"},{"location":"indexing/#Array-indexing","page":"Array indexing","title":"Array indexing","text":"Indexing out a time series is done with common bracketing semantics.","category":"section"},{"location":"indexing/#Row-indexing","page":"Array indexing","title":"Row indexing","text":"","category":"section"},{"location":"indexing/#Integer","page":"Array indexing","title":"Integer","text":"Example Description Indexing value\n[1] First row of data only single integer\n[1:3] First through third row only integer range\n[1:2:10] Odd row between first to tenth row integer range with step\n[[1:3; 8]] First through third row and eight row integer range & single integer\n[end] Last row \n\nExamples in REPL:\n\nohlc[1]\nohlc[1:3]\nohlc[1:2:10]\nohlc[[1:3; 8]]\nohlc[end]","category":"section"},{"location":"indexing/#Date-and-DateTime","page":"Array indexing","title":"Date and DateTime","text":"Example Description Indexing value\n[Date(2000, 1, 3)] The row containing Jan 3, 2000 timestamp single Date\n[[Date(2000, 1, 3), Date(2000, 2, 4)]] The rows containing Jan 3 & Feb 4, 2000 multiple Dates\n[Date(2000, 1, 3):Day(1):Date(2000, 2, 4)] The rows between Jan 3, 2000 & Feb 4, 2000 range of Date\n\nExamples in REPL:\n\nohlc[Date(2000, 1, 3)]\nohlc[Date(2000, 1, 3):Day(1):Date(2000, 2, 4)]","category":"section"},{"location":"indexing/#Column-indexing","page":"Array indexing","title":"Column indexing","text":"","category":"section"},{"location":"indexing/#Symbol","page":"Array indexing","title":"Symbol","text":"Example Description Indexing value\n[:Open] The column named :Open single symbol\n[:Open, :Close] The columns named :Open and :Close multiple symbols\n[[:Open, :Close]] The columns named :Open and :Close multiple symbols\n\nExamples in REPL:\n\nohlc[:Open]\nohlc[:Open, :Close]\ncols = [:Open, :Close]\nohlc[cols]","category":"section"},{"location":"indexing/#Mixed-approach","page":"Array indexing","title":"Mixed approach","text":"Example Description Indexing value\n[1:3, :Open] :Open column & first 3 rows single symbol & integer range\n[:Open][Date(2000, 1, 3)] :Open column and Jan 3, 2000 single symbol & Date\n\nExamples in REPL:\n\nohlc[1:3, :Open]\nohlc[:Open][Date(2000, 1, 3)]","category":"section"},{"location":"timearray/#The-TimeArray-time-series-type","page":"The TimeArray time series type","title":"The TimeArray time series type","text":"The TimeArray time series type is defined here (with inner constructor code removed for readability):\n\nstruct TimeArray{T,N,D<:TimeType,A<:AbstractArray{T,N}} <: AbstractTimeSeries{T,N,D}\n    timestamp::Vector{D}\n    values::A # some kind of AbstractArray{T,N}\n    colnames::Vector{Symbol}\n    meta::Any\n\n    # inner constructor code enforcing invariants\nend\n\nThere are four fields for the type.","category":"section"},{"location":"timearray/#timestamp","page":"The TimeArray time series type","title":"timestamp","text":"The timestamp field consists of a vector of values of a child type of of TimeType - in practise either Date or DateTime. The DateTime type is similar to the Date type except it represents time frames smaller than a day. For the construction of a TimeArray to work, this vector needs to be sorted. If the vector includes dates that are not sequential, the construction of the object will error out. The vector also needs to be ordered from oldest to latest date, but this can be handled by the constructor and will not prohibit an object from being created.","category":"section"},{"location":"timearray/#values","page":"The TimeArray time series type","title":"values","text":"The values field holds the data from the time series and its row count must match the length of the timestamp array. If these do not match, the constructor will fail. All the values inside the values array must be of the same type.","category":"section"},{"location":"timearray/#colnames","page":"The TimeArray time series type","title":"colnames","text":"The colnames field is a vector of Symbol and contains the names of the columns for each column in the values field. The length of this vector must match the column count of the values array, or the constructor will fail. Since TimeArrays are indexable on column names, duplicate names in the colnames vector will be modified by the inner constructor. Each subsequent duplicate name will be appended by _n where n enumerates from 1.","category":"section"},{"location":"timearray/#meta","page":"The TimeArray time series type","title":"meta","text":"The meta field defaults to holding nothing, which is represented by type Nothing. This default is designed to allow programmers to ignore this field. For those who wish to utilize this field, meta can hold common types such as String or more elaborate user-defined types. One might want to assign a name to an object that is immutable versus relying on variable bindings outside of the object's type fields.","category":"section"},{"location":"timearray/#Constructors","page":"The TimeArray time series type","title":"Constructors","text":"","category":"section"},{"location":"timearray/#Fields-getter-functions","page":"The TimeArray time series type","title":"Fields getter functions","text":"There are four field getter functions exported. They are named as same as the field names.\n\ntimestamp\nvalues\ncolnames\nmeta","category":"section"},{"location":"timearray/#TimeSeries.TimeArray","page":"The TimeArray time series type","title":"TimeSeries.TimeArray","text":"TimeArray{T,N,D<:TimeType,A<:AbstractArray{T,N}} <: AbstractTimeSeries{T,N,D}\n\nConstructors\n\nTimeArray(timestamp, values[, colnames, meta = nothing])\nTimeArray(ta::TimeArray; timestamp, values, colnames, meta)\nTimeArray(data::NamedTuple; timestamp, meta = nothing)\nTimeArray(table; timestamp::Symbol, timeparser::Callable = identity)\n\nThe second constructor yields a new TimeArray with the new given fields. Note that the unchanged fields will be shared, there aren't any copy for the underlying arrays.\n\nThe third constructor builds a TimeArray from a NamedTuple.\n\nArguments\n\ntimestamp::AbstractVector{<:TimeType}: a vector of sorted timestamps,\ntimestamp::Symbol: the column name of the time index from the source table. The constructor is used for the Tables.jl package integration.\nvalues::AbstractArray: a data vector or matrix. Its number of rows should match the length of timestamp.\ncolnames::Vector{Symbol}: the column names. Its length should match the column of values.\nmeta::Any: a user-defined metadata.\ntimeparser::Callable: a mapping function for converting the source time index. For instance, Dates.unix2datetime is a common case.\n\nExamples\n\ndata = (datetime = [DateTime(2018, 11, 21, 12, 0), DateTime(2018, 11, 21, 13, 0)],\n        col1 = [10.2, 11.2],\n        col2 = [20.2, 21.2],\n        col3 = [30.2, 31.2])\nta = TimeArray(data; timestamp = :datetime, meta = \"Example\")\n\n\n\n\n\n","category":"type"},{"location":"timearray/#TimeSeries.timestamp","page":"The TimeArray time series type","title":"TimeSeries.timestamp","text":"timestamp(ta::TimeArray)\n\nGet the time index of a TimeArray.\n\n\n\n\n\n","category":"function"},{"location":"timearray/#Base.values","page":"The TimeArray time series type","title":"Base.values","text":"values(ta::TimeArray)\n\nGet the underlying value table of a TimeArray.\n\n\n\n\n\n","category":"function"},{"location":"timearray/#TimeSeries.colnames","page":"The TimeArray time series type","title":"TimeSeries.colnames","text":"colnames(ta::TimeArray)\n\nGet the column names of a TimeArray.\n\nExamples\n\njulia> colnames(ohlc)\n4-element Array{Symbol,1}:\n :Open\n :High\n :Low\n :Close\n\n\n\n\n\n","category":"function"},{"location":"timearray/#TimeSeries.meta","page":"The TimeArray time series type","title":"TimeSeries.meta","text":"meta(ta::TimeArray)\n\nGet the user-defined metadata of a TimeArray.\n\n\n\n\n\n","category":"function"},{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"TimeSeries is a registered package. To add it to your Julia packages, simply do the following in REPL:\n\njulia> Pkg.add(\"TimeSeries\")\n\n\nThroughout this tutorial, we'll be using historical financial data sets, which are made available in the MarketData package. MarketData is also registered and can be added:\n\njulia> Pkg.add(\"MarketData\")\n\n\nTo create dummy data without using the MarketData package, simply use the following code block:\n\nusing Dates\ndates = Date(2018, 1, 1):Day(1):Date(2018, 12, 31)\nta = TimeArray(dates, rand(length(dates)))","category":"section"},{"location":"operators/#Mathematical,-comparison,-and-logical-operators","page":"Mathematical, comparison, and logical operators","title":"Mathematical, comparison, and logical operators","text":"TimeSeries supports common mathematical (such as .+), comparison (such as .==) , and logic (such as .&) operators. The operations are only calculated on values that share a timestamp. All of the operations must be treat as dot-call.","category":"section"},{"location":"operators/#Mathematical","page":"Mathematical, comparison, and logical operators","title":"Mathematical","text":"Mathematical operators create a TimeArray object where values are computed on shared timestamps when two TimeArray objects are provided. Operations between a single TimeArray and Int or Float are also supported. The number can precede the TimeArray object or vice versa (e.g. cl .+ 2 or 2 .+ cl). Broadcasting single-column arrays over multiple columns to perform operations is also supported.\n\nThe exclusion of / and ^ from this logic are special cases. In matrix operations / has been confused with being equivalent to the inverse, and because of the confusion base has excluded it. It is likewise excluded here. Base uses ^ to indicate matrix self-multiplication, and so it is not implemented in this context.\n\nOperator Description\n.+ arithmetic element-wise addition\n.- arithmetic element-wise subtraction\n.* arithmetic element-wise multiplication\n./ arithmetic element-wise division\n.^ arithmetic element-wise exponentiation\n.% arithmetic element-wise remainder","category":"section"},{"location":"operators/#Comparison","page":"Mathematical, comparison, and logical operators","title":"Comparison","text":"Comparison operators create a TimeArray of type Bool. Values are compared on shared timestamps when two TimeArray objects are provided. Broadcasting single-column arrays over multiple columns to perform comparisons is supported, as are comparisons between a single TimeArray and Int, Float, or Bool values. The semantics of an non-dot operators (>) is unclear, and such operators are not supported.\n\nOperator Description\n.> element-wise greater-than comparison\n.< element-wise less-than comparison\n.== element-wise equivalent comparison\n.>= element-wise greater-than or equal comparison\n.<= element-wise less-than or equal comparison\n.!= element-wise not-equivalent comparison","category":"section"},{"location":"operators/#Logic","page":"Mathematical, comparison, and logical operators","title":"Logic","text":"Logical operators are defined for TimeArrays of type Bool and return a TimeArray of type Bool. Values are computed on shared timestamps when two TimeArray objects are provided. Operations between a single TimeArray and Bool are also supported.\n\nOperator Description\n.& element-wise logical AND\n.| element-wise logical OR\n.!, .~ element-wise logical NOT\n.⊻ element-wise logical XOR","category":"section"},{"location":"split/#Splitting-by-conditions","page":"Splitting by conditions","title":"Splitting by conditions","text":"Specific methods for segmenting on time ranges or if condition is met is supported with the following methods.","category":"section"},{"location":"split/#when","page":"Splitting by conditions","title":"when","text":"The when methods allows aggregating elements from a TimeArray into specific time periods, such as Mondays or the month of October:\n\nusing TimeSeries\nusing MarketData\nwhen(cl, dayofweek, 1)\nwhen(cl, dayname, \"Monday\")\n\nThe period argument holds a valid Date method. Below are currently available alternatives.\n\nDates method Example\nday Jan 3, 2000 = 3\ndayname Jan 3, 2000 = \"Monday\"\nweek Jan 3, 2000 = 1\nmonth Jan 3, 2000 = 1\nmonthname Jan 3, 2000 = \"January\"\nyear Jan 3, 2000 = 2000\ndayofweek Monday = 1\ndayofweekofmonth Fourth Monday in Jan = 4\ndayofyear Dec 31, 2000 = 366\nquarterofyear Dec 31, 2000 = 4\ndayofquarter Dec 31, 2000 = 93","category":"section"},{"location":"split/#from","page":"Splitting by conditions","title":"from","text":"The from method truncates a TimeArray starting with the date passed to the method:\n\nusing TimeSeries\nusing MarketData\n\nfrom(cl, Date(2001, 12, 27))","category":"section"},{"location":"split/#to","page":"Splitting by conditions","title":"to","text":"The to method truncates a TimeArray after the date passed to the method:\n\nusing TimeSeries\nusing MarketData\n\nto(cl, Date(2000, 1, 5))","category":"section"},{"location":"split/#findwhen","page":"Splitting by conditions","title":"findwhen","text":"The findwhen method test a condition and returns a vector of Date or DateTime where the condition is true:\n\nusing TimeSeries\nusing MarketData\n\ngreen = findwhen(ohlc[:Close] .> ohlc[:Open]);\ntypeof(green)\nohlc[green]","category":"section"},{"location":"split/#findall","page":"Splitting by conditions","title":"findall","text":"The findall method tests a condition and returns a vector of Int representing the row in the array where the condition is true:\n\nusing TimeSeries\nusing MarketData\n\nred = findall(ohlc[:Close] .< ohlc[:Open]);\ntypeof(red)\nohlc[red]\n\nThe following example won't create a temporary Bool vector, and gains better performance.\n\nfindall(>(100), cl)","category":"section"},{"location":"split/#Splitting-by-head-and-tail","page":"Splitting by conditions","title":"Splitting by head and tail","text":"","category":"section"},{"location":"split/#head","page":"Splitting by conditions","title":"head","text":"The head method defaults to returning only the first value in a TimeArray. By selecting the second positional argument to a different value, the user can modify how many from the top are selected:\n\nusing TimeSeries\nusing MarketData\n\nhead(cl)","category":"section"},{"location":"split/#tail","page":"Splitting by conditions","title":"tail","text":"The tail method defaults to returning only the last value in a TimeArray. By selecting the second positional argument to a different value, the user can modify how many from the bottom are selected:\n\nusing TimeSeries\nusing MarketData\n\ntail(cl)\ntail(cl, 3)","category":"section"},{"location":"split/#Splitting-by-period","page":"Splitting by conditions","title":"Splitting by period","text":"Splitting data by a given function, e.g. Dates.day into periods.\n\nusing TimeSeries\nusing MarketData\n\nsplit(cl, Dates.day)","category":"section"},{"location":"readwrite/#I/O","page":"I/O","title":"I/O","text":"Reading/writing a csv file into a TimeArray object is supported.","category":"section"},{"location":"readwrite/#readtimearray","page":"I/O","title":"readtimearray","text":"The readtimearray method is a wrapper for the DelimitedFiles.readdlm method that returns a TimeArray.\n\nreadtimearray(fname; delim=',', meta=nothing, format=\"\")\n\nThe fname argument is a string that represents the location and name of the csv file that you wish to parse into a TimeArray object. Optionally, you can add a value to the meta field.\n\nMore generally, this function accepts arbitrary delimiters with delim, just like DelimitedFiles.readdlm.\n\nFor DateTime data that has odd formatting, a format argument is provided where users can pass the format of their data.\n\nFor example:\n\nta = readtimearray(\"close.csv\"; format=\"dd/mm/yyyy HH:MM\", delim=';')\n\nA more robust regex parsing engine is planned so users will not need to pass a time format for anything but the most edge cases.","category":"section"},{"location":"readwrite/#writetimearray","page":"I/O","title":"writetimearray","text":"The writetimearray method writes a TimeArray to the specified file as comma-separated values. For example:\n\njulia> writetimearray(cl[1:5], \"close.csv\")\n\nshell> cat close.csv\nTimestamp,Close\n2000-01-03,111.94\n2000-01-04,102.5\n2000-01-05,104.0\n2000-01-06,95.0\n2000-01-07,99.5","category":"section"},{"location":"plotting/#Plotting","page":"Plotting","title":"Plotting","text":"TimeSeries defines a recipe that allows plotting to a number of different plotting packages using the Plots.jl framework (no plotting packages will be automatically installed by TimeSeries).\n\nHere we use the data from Yahoo Fiance as a demo.\n\nusing Plots, MarketData, TimeSeries\ndefault(; show=false)  # hide\nENV[\"GKSwstype\"] = \"100\" # hide\ngr()\nta = yahoo(:GOOG, YahooOpt(; period1=now() - Month(1)))","category":"section"},{"location":"plotting/#Plotting-as-multiple-series","page":"Plotting","title":"Plotting as multiple series","text":"The recipe allows TimeArray objects to be passed as input to plot.  The recipe will plot each variable as an individual line, aligning all variables to the same y axis.\n\nplot(ta[:Open, :High, :Low, :Close])\nsavefig(\"multi-series.svg\");\nnothing; # hide\n\n(Image: )","category":"section"},{"location":"plotting/#Plotting-candlestick","page":"Plotting","title":"Plotting candlestick","text":"We have seriestype = :candlestick support that requires four columns exist in the input. They are open, high, low and close (case-insensitive).\n\nplot(ta; seriestype=:candlestick)\nsavefig(\"cs.svg\");\nnothing; # hide\n\n(Image: )","category":"section"},{"location":"plotting/#Other-available-attributes","page":"Plotting","title":"Other available attributes","text":"bar_width::Float64 the valid value is from 0 to 1.\n\nplot(ta; seriestype=:candlestick, bar_width=0.7)\nsavefig(\"bw.svg\");\nnothing; # hide\n\n(Image: )\n\nxticks::Int for controlling the density of x axis labels.\n\nplot(ta; seriestype=:candlestick, xticks=3, xrotation=60)\nsavefig(\"xticks.svg\");\nnothing; # hide\n\n(Image: )","category":"section"},{"location":"#TimeSeries-Overview","page":"TimeSeries Overview","title":"TimeSeries Overview","text":"The TimeSeries package provides convenient methods for working with time series data in Julia.","category":"section"},{"location":"#Contents","page":"TimeSeries Overview","title":"Contents","text":"Pages = [\n  \"getting_started.md\",\n  \"timearray.md\",\n  \"indexing.md\",\n  \"split.md\",\n  \"modify.md\",\n  \"operators.md\",\n  \"apply.md\",\n  \"combine.md\",\n  \"readwrite.md\",\n  \"tables.md\",\n  \"plotting.md\",\n  \"retime.md\",\n]","category":"section"},{"location":"tables/#Tables.jl-Interface-Integration","page":"Tables.jl Interface Integration","title":"Tables.jl Interface Integration","text":"Quoted from the home page of Tables.jl:\n\nThe Table.jl package provides simple, yet powerful interface functions for working with all kinds tabular data through predictable access patterns.\n\nThe integration provides handy constructor to convert a table between several types. The time index of a TimeArray is considered as a normal data column named timestamp.\n\nHere this doc shows some example usages of this integration. Converting table between DataFrames or CSV are quite common cases.","category":"section"},{"location":"tables/#eachrow-and-eachcol-iterators","page":"Tables.jl Interface Integration","title":"eachrow and eachcol iterators","text":"In Julia v1.1+, these two functions are supported and baked by Tables.jl.\n\nusing MarketData\nfor row in eachrow(ohlc)\n    time = row.timestamp\n    c = row.Close\n    # ...\nend","category":"section"},{"location":"tables/#TimeArray-to-DataFrame","page":"Tables.jl Interface Integration","title":"TimeArray to DataFrame","text":"using MarketData, DataFrames\ndf = DataFrame(ohlc)","category":"section"},{"location":"tables/#DataFrame-to-TimeArray","page":"Tables.jl Interface Integration","title":"DataFrame to TimeArray","text":"In this case, user needs to point out the column of time index via the timestamp keyword argument.\n\ndf′ = DataFrames.rename(df, :timestamp => :A);\nfirst(df′)\nTimeArray(df′; timestamp=:A)","category":"section"},{"location":"tables/#Save-a-TimeArray-via-CSV.jl","page":"Tables.jl Interface Integration","title":"Save a TimeArray via CSV.jl","text":"using CSV\nCSV.write(filename, ta)","category":"section"},{"location":"tables/#Load-a-TimeArray-from-csv-file-via-CSV.jl","page":"Tables.jl Interface Integration","title":"Load a TimeArray from csv file via CSV.jl","text":"using CSV\nTimeArray(CSV.File(filename); timestamp=:timestamp)","category":"section"}]
}
